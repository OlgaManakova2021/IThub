<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Объекты и массивы</title>
</head>
<body>
<script>
       
    //Создание пустого объекта:
        // let user = new Object(); // синтаксис "конструктор объекта"
        // let user = {};  // синтаксис "литерал объекта"
 

    //Создание объекта со значениями:
        let user = {     // объект
            name: "John",  // под ключом "name" хранится значение "John"
            age: 30,        // под ключом "age" хранится значение 30
            "likes birds": true,
        };

    //Для обращения к свойствам используется запись «через точку»:
    // получаем свойства объекта:
            console.log( user.name ); // John
            console.log( user.age ); // 30
            console.log(user["likes birds"]); // true

    // Оператор in    
            alert( "age" in user ); // true, user.age существует
            alert( "blabla" in user ); // false, user.blabla не существует
 

    // Использовать оператор лучше на случай, если свойство на самом деле существует, но хранит значение undefined.
            let obj = {
                test: undefined
            };
            alert( obj.test ); //  выведет undefined, значит свойство не существует?
            alert( "test" in obj ); // true, свойство существует!

    // Дополнительные методы работы с объектами (delete, сравнение объектов)
    // Для удаления свойств используют оператор delete:
            const book = {
	            title: 'Война и мир',
	            author: 'Лев Толстой',
	            pages: 1274,
                isFinished: true,
                usersReading: [1946, 1293, 7743]
                }
            delete book.usersReading
            delete book['isFinished']
            console.log(book) // { title: 'Война и мир', author: 'Лев Толстой', pages: 1274 }
 

            // Чаще всего свойства не удаляют, а сбрасывают значение, устанавливая undefined или подходящее по смыслу:
            // const book1 = {
            // 	title: 'Война и мир',
            // 	author: 'Лев Толстой',
            // 	pages: 1274,
            // 	isFinished: true,
            // 	usersReading: [1946, 1293, 7743]
            // }

            // book.usersReading = undefined
            // book['isFinished'] = undefined

            // {
            //    title: 'Война и мир',
            //    author: 'Лев Толстой',
            //    pages: 1274
            //    isFinished: undefined,
            //    usersReading: undefined
            // }
            

// Объект - ссылочный тип данных, поэтому при сравнении двух объектов JavaScript сравнивает не значения 
//свойств этих объектов, а адреса в памяти, по которым эти объекты хранятся. Любое сравнение двух 
//объектов будет возвращать false, даже если они выглядят одинаково:
 

// создаётся один объект
const book2 = { title: 'Дюна' }

// создаётся другой объект
const anotherBook = { title: 'Дюна' }

console.log(book === anotherBook) // false
 

// Сравнение будет возвращать true, только если мы сравниваем переменные,
//указывающие на один и тот же объект:

// создаётся один объект
const book3 = { title: 'Дюна' }

// в anotherBook записывается ссылка на объект
const anotherBook1 = book

console.log(book === anotherBook) // true




//Объекты обычно создаются, чтобы представлять сущности реального мира, 
//будь то пользователи, заказы и так далее:

// Объект пользователя
let user = {
	name: "John",
	age: 30
};
 
//И так же, как и в реальном мире, пользователь может совершать действия: 
//выбирать что-то из корзины покупок, авторизовываться, выходить из системы, оплачивать и т.п.
//Такие действия в JavaScript представлены функциями в свойствах.

//Для начала давайте научим нашего пользователя user здороваться:

user.sayHi = function() {
	alert("Привет!");
};

user.sayHi(); // Привет!
 

//Функцию, которая является свойством объекта, называют методом этого объекта.

//Существует более короткий синтаксис для методов в литерале объекта:
 
user = {
	sayHi() { 
        alert("Привет");
	}
};
 
//Ключевое слово «this» в методах
//Как правило, методу объекта обычно требуется доступ к информации, 
//хранящейся в объекте, для выполнения своей работы.

//Например, коду внутри user.sayHi() может потребоваться имя пользователя, 
//которое хранится в объекте user. Для доступа к информации внутри объекта 
//метод может использовать ключевое слово this.
//Значение this – это объект «перед точкой», который используется для вызова метода.

let user = {
	name: "John",
	age: 30,
	sayHi() {
		// "this" - это "текущий объект".
		alert(this.name);
	}
};

user.sayHi(); // John
 
//Здесь во время выполнения кода user.sayHi() значением this 
//будет являться user (ссылка на объект user). 
//Технически также возможно получить доступ к объекту без ключевого слова this, 
//обратившись к нему через внешнюю переменную (в которой хранится ссылка на этот объект):

let user = {
	name: "John",
	age: 30,
	sayHi() {
		alert(user.name); // "user" вместо "this"
	}
};

//такой код ненадёжен. Если мы решим скопировать ссылку на объект user в другую переменную, 
//например, admin = user, и перезапишем переменную user чем-то другим, 
//тогда будет осуществлён доступ к неправильному объекту при вызове метода из admin.

let user = {
	name: "John",
	age: 30,
	sayHi() {
		alert( user.name ); // приведёт к ошибке
	}
};

let admin = user;
user = null; // перезапишем переменную для наглядности, теперь она не хранит ссылку на объект.
admin.sayHi(); // TypeError: Cannot read property 'name' of null

//Если бы мы использовали this.name вместо user.name внутри alert, тогда этот код бы сработал.


/*В случае, когда необходимо создать много однотипных объектов, 
используется так называемая функция-конструктор и оператор new.

Функция-конструктор - функция, которая принимает входные аргументы, 
создаёт и возвращает объект определённого вида.
Функция-конструктор - обычная функция, но с такими оговорками:
1. Её название обязательно должно начинаться с большой буквы
2. Она выполняется только с помощью оператора new таким образом:
*/

function User(name) {
	this.name = name;
	this.isAdmin = false;
}

let user = new User("Jack");
alert(user.name); // Jack
alert(user.isAdmin); // false
 
/*
Когда функция вызывается как new User(...), происходит следующее:

1. Создаётся новый пустой объект, и он присваивается this.
2. Выполняется тело функции. Обычно оно модифицирует this, добавляя туда новые свойства.
3. Возвращается значение this.

Другими словами, new User(...) делает что-то вроде:

function User(name) {
	// this = {};  (неявно)
	// добавляет свойства к this
	this.name = name;
	this.isAdmin = false;
	// return this;  (неявно)
}
 
Таким образом, let user = new User("Jack") возвращает тот же результат, что и:

let user = {
	name: "Jack",
	isAdmin: false
};
 
Теперь, если нам будет необходимо создать других пользователей, 
мы можем просто вызвать new User("Ann"), new User("Alice") и так далее. 
Данная конструкция гораздо удобнее и читабельнее, 
чем многократное создание литерала объекта.

Это и является основной целью конструкторов – реализовать код 
для многократного создания однотипных объектов.


Классы

Вместо функции-конструктора можно использовать конструкцию class.
Её синтаксис:

class MyClass {
	// методы класса
	constructor() { ... }
	method1() { ... }
	method2() { ... }
	method3() { ... }
	...
}
 
Затем используйте вызов new MyClass() для создания нового объекта 
со всеми перечисленными методами.
При этом автоматически вызывается метод constructor(), 
в нём мы можем инициализировать объект.
*/
 
class User {
	constructor(name) {
  		this.name = name;
	}
	
	sayHi() {
		alert(this.name);
	}
}

// Использование:
let user1 = new User("Иван");
user1.sayHi();
 
/*
Когда вызывается new User("Иван"):

1. Создаётся новый объект.
2. constructor запускается с заданным аргументом и сохраняет его в this.name.
*/


/*
Наследование классов – это способ расширения одного класса другим классом.
Допустим, у нас есть класс Animal:
*/
 
class Animal {
	constructor(name) {
		this.speed = 0;
		this.name = name;
	}
	
	run(speed) {
		this.speed = speed;
		alert(`${this.name} бежит со скоростью ${this.speed}.`);
	}
	
	stop() {
		this.speed = 0;
		alert(`${this.name} стоит неподвижно.`);
	}
}

let animal = new Animal("Мой питомец");
 

/*
…И мы хотели бы создать ещё один class Rabbit.
Поскольку кролики – это животные, класс Rabbit должен быть 
основан на Animal, и иметь доступ к методам животных, 
так чтобы кролики могли делать то, что могут делать «общие» животные.

Синтаксис для расширения другого класса следующий: class Child extends Parent.

Давайте создадим class Rabbit, который наследуется от Animal:
*/
 
class Rabbit extends Animal {
	hide() {
		alert(`${this.name} прячется!`);
 	}
}

let rabbit1 = new Rabbit("Белый кролик");
rabbit1.run(5); // Белый кролик бежит со скоростью 5.
rabbit1.hide(); // Белый кролик прячется!

/*
Объект класса Rabbit имеет доступ как к методам Rabbit, 
таким как rabbit.hide(), так и к методам Animal, таким как rabbit.run().


Переопределение методов
Теперь давайте продвинемся дальше и переопределим метод. По умолчанию все методы, 
не указанные в классе Rabbit, берутся непосредственно «как есть» из класса Animal.
Но если мы укажем в Rabbit собственный метод, например stop(), 
то он будет использован вместо него:

 
class Rabbit extends Animal {
	stop() {
	// ...теперь это будет использоваться для rabbit.stop()
   	// вместо stop() из класса Animal
 	}
}
 

Впрочем, обычно мы не хотим полностью заменить родительский метод, 
а скорее хотим сделать новый на его основе, изменяя или расширяя его функциональность. 
Мы делаем что-то в нашем методе и вызываем родительский метод до/после или в процессе.

У классов есть ключевое слово "super" для таких случаев:

super.method(...)     	вызывает родительский метод
super(...)	            для вызова родительского конструктора 
                        (работает только внутри нашего конструктора)

Пусть наш кролик автоматически прячется при остановке:
*/

class Rabbit2 extends Animal {
 	hide() {
   		alert(`${this.name} прячется!`);
 	}
 
 	stop() {
   		super.stop(); // вызываем родительский метод stop
   		this.hide(); // и затем hide
 	}
}

let rabbit2 = new Rabbit2("Белый кролик");
rabbit2.run(5); // Белый кролик бежит со скоростью 5.
rabbit2.stop(); // Белый кролик стоит. Белый кролик прячется!
 

/*Теперь у класса Rabbit есть метод stop, который вызывает родительский
 super.stop() в процессе выполнения.


Переопределение конструктора
С конструкторами немного сложнее.

До сих пор у Rabbit не было своего конструктора.

Согласно спецификации, если класс расширяет другой класс и не имеет конструктора, 
то автоматически создаётся такой «пустой» конструктор:
 
class Rabbit extends Animal {
	// генерируется для классов-потомков, у которых нет своего конструктора
 	constructor(...args) {
   		super(...args);
 	}
}
 
Как мы видим, он просто вызывает конструктор родительского класса. 
Так будет происходить, пока мы не создадим собственный конструктор.

Конструкторы в наследуемых классах должны обязательно вызывать super(...) и 
делать это перед использованием this!

Давайте добавим конструктор для Rabbit. Он будет устанавливать earLength в дополнение к name:



class Animal {
 	constructor(name) {
   		this.speed = 0;
   		this.name = name;
 	}
	// ...
}
*/

class Rabbit extends Animal {
 	constructor(name, earLength) {
   		super(name);
   		this.earLength = earLength;
 	}
 	// ...
}

let rabbit = new Rabbit("Белый кролик", 10);
alert(rabbit.name); // Белый кролик
alert(rabbit.earLength); // 10


</script>
</body>
</html>